var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [HJB]","category":"page"},{"location":"api/#HJB.CentralGradient","page":"API","title":"HJB.CentralGradient","text":"CentralGradient()\n\nReturns second order central gradient, \n\nfracui+1 - ui-12 dx\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.CentralWenoGradient","page":"API","title":"HJB.CentralWenoGradient","text":"CentralWenoGradient(ϵ=1e-6)\n\nReturns the fifth order central WENO gradient, i.e., the average of the left and right Weno gradients.\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.GradientMethod","page":"API","title":"HJB.GradientMethod","text":"GradientMethod\n\nabstract type defining the method used to determine the spatial gradient of a grid. Given G <: GradientMethod, the general form is gradient(G, data, grid, ind, dim) to get the gradient of the array data at ind along dim dimension in a grid.  \n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.Grid","page":"API","title":"HJB.Grid","text":"Grid(x0, dx, Ns)\n\nparameterize a grid, such that Array{T, D} can be mapped to a physical domain of D dimensions. \n\nindex (0, 0, ..., 0) will correspond to the physical point grid.x0\n\nNote, this package makes heavy use of OffsetArrays to do its array indexing. Use ind2state and state2ind to correctly map between indices and physical points. \n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.Grid-Union{Tuple{T}, Tuple{R}, Tuple{D}, Tuple{T, Any}} where {D, R<:AbstractRange, T<:Tuple{Vararg{R, D}}}","page":"API","title":"HJB.Grid","text":"Grid( (x1s, x2s, ...) )\n\na simpler constructor for a grid, where you pass in a tuple of xis <: AbstractRange. \n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.LeftGradient","page":"API","title":"HJB.LeftGradient","text":"LeftGradient()\n\nReturns the first order left gradient, \n\nfracui - ui-1dx\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.LeftWenoGradient","page":"API","title":"HJB.LeftWenoGradient","text":"LeftWenoGradient(ϵ=1e-6)\n\nReturns the fifth order left WENO gradient. See Sec 3.4 of Osher, Fedkiw Level Set Methods and Dynamic Implicit Surfaces\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.LocalLaxFriedrichsNHM","page":"API","title":"HJB.LocalLaxFriedrichsNHM","text":"LocalLaxFriedrichsNHM(left_grad, right_grad, dissipation_func)\n\nis a numerical hamiltonian method that implements\n\nhamil(t, x, V, ∇V) = hamil(t, x, V, (gp + gm) / 2) - α' * (gp - gm) / 2\n\nwhere gm, gp are the left and right gradients of V, and α = dissipation_func(t, x)\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.RightGradient","page":"API","title":"HJB.RightGradient","text":"RightGradient()\n\nReturns first order right gradient \n\nfracui+1 - uidx \n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.RightWenoGradient","page":"API","title":"HJB.RightWenoGradient","text":"RightWenoGradient(ϵ=1e-6)\n\nReturns the fifth order right WENO gradient.  See Sec 3.4 of Osher, Fedkiw Level Set Methods and Dynamic Implicit Surfaces\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.SimpleNHM","page":"API","title":"HJB.SimpleNHM","text":"SimpleNHM(left_grad, right_grad)\n\nis a numerical hamiltonian method that implements\n\nhamil(t, x, V, ∇V) = hamil(t, x, V, (gp + gm) / 2)\n\nwhere gm, gp are the left and right gradients V.\n\n\n\n\n\n","category":"type"},{"location":"api/#HJB.StencilGradient","page":"API","title":"HJB.StencilGradient","text":"StencilGradient(inds)\n\nReturns a stencil based gradient operator, using Fornberg's method. Actually implemented using this trick from Steven Johnson. Given a list of relative inds, it can compute the weights w_i necessary such that the derivative is approximated by\n\nfrac1dx sum_i in inds wi ui\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.step-Tuple{CartesianIndex, Integer, Integer}","page":"API","title":"Base.step","text":"step(ind, dim, n)\n\nreturn the index of the cell n steps away from ind in the dim dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.DomainIndices-Union{Tuple{HJB.Grid{D, F}}, Tuple{F}, Tuple{D}} where {D, F}","page":"API","title":"HJB.DomainIndices","text":"DomainIndices(grid)\n\nreturns a CartesianIndices of a grid that correspond to the main computation domain, i.e., excluding any padding cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.LeftBoundaryIndices-Union{Tuple{F}, Tuple{D}, Tuple{HJB.Grid{D, F}, Any}} where {D, F}","page":"API","title":"HJB.LeftBoundaryIndices","text":"LeftBoundaryIndices(grid, dim)\n\nreturns a CartesianIndices of a grid that correspond to the left boundary of the computation domain along the dim dimension\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.RightBoundaryIndices-Union{Tuple{F}, Tuple{D}, Tuple{HJB.Grid{D, F}, Any}} where {D, F}","page":"API","title":"HJB.RightBoundaryIndices","text":"RightBoundaryIndices(grid, dim)\n\nreturns a CartesianIndices of a grid that correspond to the right boundary of the computation domain along the dim dimension\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.allocate_grid-Union{Tuple{F}, Tuple{D}, Tuple{Any, HJB.Grid{D, F}, Any}, Tuple{Any, HJB.Grid{D, F}, Any, Any}} where {D, F}","page":"API","title":"HJB.allocate_grid","text":"allocate_grid([T=Float64,] grid::Grid{D, F}, f, v=0) where {D, F}\n\nreturns an OffsetArray that will be used to store the value function. The OffsetArray will store values of type T, which is Float64 by default.  The offset array is of D dimensions, and has the correct number of entries along each dimension.  Each element of the array will be filled with f(x) where x is the physical location corresponding to the grid cell. All padding cells are filled with v. \n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.allocate_grid-Union{Tuple{F}, Tuple{D}, Tuple{Any, HJB.Grid{D, F}}} where {D, F}","page":"API","title":"HJB.allocate_grid","text":"allocate_grid([T=Float64,] grid::Grid{D, F}) where {D, F}\n\nreturns an OffsetArray that will be used to store the value function. The OffsetArray will store values of type T, which is Float64 by default.  The offset array is of D dimensions, and has the correct number of entries along each dimension. \n\nElements are uninitialized.\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.getDomainAxes-Union{Tuple{F}, Tuple{D}, Tuple{HJB.Grid{D, F}, Integer}} where {D, F}","page":"API","title":"HJB.getDomainAxes","text":"getDomainAxes(grid::Grid, dim)\n\nreturns a range that defines the axis of the grid along dim. Useful for plotting. \n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.gradient-NTuple{4, Any}","page":"API","title":"HJB.gradient","text":"gradient(data, grid, ind, dim)\ngradient(method::GradientMethod, data, grid, ind, dim)\n\nreturns the gradient of data at ind along dimension dim using the grid and the method gradient method. Default method is CentralWenoGradient \n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.hjb_plot","page":"API","title":"HJB.hjb_plot","text":"hjb_plot(grid::G, data; idxs=(1,2), at=zeros(D), kwargs...) where {D, F, G<:Grid{D, F}}\n\nA plotting utility to plot the solution of a hjb.  Provide the grid, the data, and if the data is of dim > 2, also the dimensions you want to slice in, and the reference point at that you want to slice through. \n\nExamples:\n\n# create the grids\nx1s = -1:0.025:1\nx2s = -2:0.025:2\nx3s = 0.0:0.5:2.0\ngrid1 = HJB.Grid((x1s,))\ngrid2 = HJB.Grid((x1s, x2s,))\ngrid3 = HJB.Grid((x1s, x2s, x3s))\n\n# fill in some data\ndata1 = HJB.allocate_grid(grid1, x-> x[1]^2);\ndata2 = HJB.allocate_grid(grid2, x-> x[1]^2 + x[2]^2);\ndata3 = HJB.allocate_grid(grid3, x-> x[1]^2 + x[2]^2 - x[3]);\n\n# plot 1D:\nhjb_plot(grid1, data1)\n\n# plot 2D:\nhjb_plot(grid2, data2)\n\n# plot 3D:\nhjb_plot(grid3, data3, (1, 2), [0, 0, 1.0])\n\n\n\n\n\n","category":"function"},{"location":"api/#HJB.ind2state-Union{Tuple{F}, Tuple{D}, Tuple{HJB.Grid{D, F}, CartesianIndex}} where {D, F}","page":"API","title":"HJB.ind2state","text":"ind2state(grid::Grid, ind::CartesianIndex)\n\nreturns a SVector with the state at the ind in the grid\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.state2ind-Union{Tuple{F}, Tuple{D}, Tuple{HJB.Grid{D, F}, Any}} where {D, F}","page":"API","title":"HJB.state2ind","text":"state2ind(grid::Grid, state)\n\nreturns a CartesianIndex corresponding to the state in the grid\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.update_ghost_nodes!-Union{Tuple{F}, Tuple{D}, Tuple{Any, HJB.Grid{D, F}}} where {D, F}","page":"API","title":"HJB.update_ghost_nodes!","text":"update_ghost_nodes!(V, grid)\n\nV is the array that contains the value function, specified using the grid. \n\nupdates (in-place) the values of the ghost nodes, using the boundary gradients and extrapolating.  TODO(dev): support periodic boundaries\n\n\n\n\n\n","category":"method"},{"location":"api/#HJB.weno","page":"API","title":"HJB.weno","text":"weno(v, ϵ=1e-6)\n\nhelper function to compute the WENO gradient given v=(v1,v2,v3,v4,v5) See Sec 3.5 of Osher, Fedkiw, Level Set Methods and Dynamic Implicit Surfaces.\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"In this example, we will see how to use this package to solve for a CBF function for a inverted pendulum. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HJB","category":"page"},{"location":"#HJB","page":"Home","title":"HJB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HJB.","category":"page"},{"location":"spatial_derivatives/#Spatial-Derivatives","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"","category":"section"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"Once we have a grid, we can take spatial derivatives using various methods. ","category":"page"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"The syntax is ","category":"page"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"  gradient(data, grid, ind, dim)\n  gradient(method, data, grid, ind, dim)","category":"page"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"which allows you determine the gradient of the data stored in data, based on the grid at a position ind along dimension dim. You can also specify the method to use. The mathematical expressions for each are listed in the docs below.  ","category":"page"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"All of the gradient methods are sufficiently general to work in arbitrary dimensions, but assumes constant spacing of grid nodes.","category":"page"},{"location":"spatial_derivatives/#Spatial-Derivatives-API","page":"Spatial Derivatives","title":"Spatial Derivatives API","text":"","category":"section"},{"location":"spatial_derivatives/","page":"Spatial Derivatives","title":"Spatial Derivatives","text":"Modules = [HJB]\nPages = [\"spatial_derivatives.jl\"]","category":"page"},{"location":"spatial_derivatives/#HJB.CentralGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.CentralGradient","text":"CentralGradient()\n\nReturns second order central gradient, \n\nfracui+1 - ui-12 dx\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.CentralWenoGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.CentralWenoGradient","text":"CentralWenoGradient(ϵ=1e-6)\n\nReturns the fifth order central WENO gradient, i.e., the average of the left and right Weno gradients.\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.GradientMethod-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.GradientMethod","text":"GradientMethod\n\nabstract type defining the method used to determine the spatial gradient of a grid. Given G <: GradientMethod, the general form is gradient(G, data, grid, ind, dim) to get the gradient of the array data at ind along dim dimension in a grid.  \n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.LeftGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.LeftGradient","text":"LeftGradient()\n\nReturns the first order left gradient, \n\nfracui - ui-1dx\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.LeftWenoGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.LeftWenoGradient","text":"LeftWenoGradient(ϵ=1e-6)\n\nReturns the fifth order left WENO gradient. See Sec 3.4 of Osher, Fedkiw Level Set Methods and Dynamic Implicit Surfaces\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.RightGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.RightGradient","text":"RightGradient()\n\nReturns first order right gradient \n\nfracui+1 - uidx \n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.RightWenoGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.RightWenoGradient","text":"RightWenoGradient(ϵ=1e-6)\n\nReturns the fifth order right WENO gradient.  See Sec 3.4 of Osher, Fedkiw Level Set Methods and Dynamic Implicit Surfaces\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#HJB.StencilGradient-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.StencilGradient","text":"StencilGradient(inds)\n\nReturns a stencil based gradient operator, using Fornberg's method. Actually implemented using this trick from Steven Johnson. Given a list of relative inds, it can compute the weights w_i necessary such that the derivative is approximated by\n\nfrac1dx sum_i in inds wi ui\n\n\n\n\n\n","category":"type"},{"location":"spatial_derivatives/#Base.step-Tuple{CartesianIndex, Integer, Integer}-spatial_derivatives","page":"Spatial Derivatives","title":"Base.step","text":"step(ind, dim, n)\n\nreturn the index of the cell n steps away from ind in the dim dimension.\n\n\n\n\n\n","category":"method"},{"location":"spatial_derivatives/#HJB.gradient-NTuple{4, Any}-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.gradient","text":"gradient(data, grid, ind, dim)\ngradient(method::GradientMethod, data, grid, ind, dim)\n\nreturns the gradient of data at ind along dimension dim using the grid and the method gradient method. Default method is CentralWenoGradient \n\n\n\n\n\n","category":"method"},{"location":"spatial_derivatives/#HJB.weno-spatial_derivatives","page":"Spatial Derivatives","title":"HJB.weno","text":"weno(v, ϵ=1e-6)\n\nhelper function to compute the WENO gradient given v=(v1,v2,v3,v4,v5) See Sec 3.5 of Osher, Fedkiw, Level Set Methods and Dynamic Implicit Surfaces.\n\n\n\n\n\n","category":"function"}]
}
